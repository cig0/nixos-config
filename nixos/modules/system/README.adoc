= ucode.nix

v1.0, 2024-02-06

== Rationale Behind Design Decisions

____
This section explains the reasoning behind the design decisions that led me the way I went when creating this `ucode.nix` module. _This is the way._
____

I was considering automating the guessing of the CPU manufacturer, but since that approach would require running tools like `cpu-vendor`, `awk` and `grep`—meaning they’d need to be installed on the system and would make the solution heavier—I thought I might as well move the `ucode.nix` module settings under each respective host umbrella directory, and declare them explicitly there.

Now, I normally try to avoid this because I firmly believe that any code that can be shared and reused should be. However, if you check out the tree graph I shared above, you'll see that there's already a `keybd.nix` module in the host directory. That’s because the information in that module is specific to the keyboard of that particular host, so it wouldn’t make sense to include it in the general `keybd.nix` module in the common modules section.

Also, I’m really keen on avoiding any kind of “magic” in my modules—especially when it comes to specifics like CPU type, display, or keyboard (as with `keybd.nix`).

So here’s the crux of the matter:

- (1) *Making the flake impure:* I absolutely refuse to do this.
- (2) *Using an external variable:* This is the best approach in some contexts, e.g. in CI/CD pipelines, but feels "odd" on personal systems. That said, I'm still considering it.
- (3) *Sticking with the `runCommand` approach:* This method introduces some automatic detection magic, adds dependency on external tools (like cpu-vendor, awk, and grep), and makes flake evaluation slower and heavier; it's the best option, though, for a seemless experience if managing only a bunch of hosts.
- (4) *Defining the `updateMicrocode` setting within the host directory:* This seems like a reasonable compromise.

About the last option I don’t think this is the worst case of having modules tied closely to a host. I could just slap that setting into the main `configuration.nix` file, but I prefer to give it its own module to fully exploit the power and expressiveness of flakes. This way, I can declutter the main configuration file, achieve better visibility, and make the flake structure easier to understand and navigate.

== Here's ChatGPT 4.o analysis

=== Automated CPU Manufacturer Guessing vs. Explicit Declaration

**Automated Guessing:**
Your idea was to automate CPU vendor detection, but it hinges on using external tools (like `awk`, `grep`, or even a custom tool like `cpu-vendor`), which increases dependencies and can slow down flake evaluation.

**Explicit Declaration:**
Moving the `ucode.nix` module into the host’s umbrella (e.g., under `nixos/hosts/TUXEDOInfinityBookPro/`) and declaring it explicitly avoids making the flake impure. This provides predictability and a clearer dependency graph at the cost of some code duplication or less reusability.

=== Sharing vs. Host-Specific Customization

**Sharing Modules:**
You favor reusable modules when possible. That’s a solid principle: shared code minimizes redundancy and ensures consistency across systems.

**Host-Specific Modules:**
However, as you pointed out with `keybd.nix`, some settings are too specific (like keyboard settings tied to the TUXEDO InfinityBookPro), and it makes sense to keep them local. This aligns with the idea of _“don’t force generality”_ if a piece of logic only makes sense in one context.

=== Avoiding “Magic” in Modules

You have a clear preference for explicit configuration rather than hidden behavior. Magic can obscure the rationale behind decisions and complicate debugging.

The `runCommand` approach introduces subtle behavior by depending on runtime tools and might cause side effects that are hard to track. Keeping things declarative and explicit—even if it means a bit more boilerplate—helps maintain clarity.

=== Evaluating Alternatives

- **Flake Impurity:**
  Making the flake impure would allow some dynamic behavior but breaks the deterministic nature of flakes. You’re right to resist this because flakes aim for purity and reproducibility.

- **External Variable:**
  Passing an external variable can be a neat solution in CI/CD pipelines or environments where configuration is injected. However, it might add an extra layer of configuration management, which could complicate local development.

- **RunCommand Approach:**
  This method, while clever, relies on extra tools and can add _“magic”_ that obscures the source of truth in your configuration. It’s a trade-off: automation versus explicit clarity.

- **Host Umbrella Declaration:**
  Placing the `updateMicrocode` setting within the host directory is an acceptable compromise. It keeps your flake evaluation pure, avoids external dependencies, and makes the configuration’s structure clear. Plus, it leverages the modularity of flakes by isolating host-specific settings.

=== Overall Recommendation and Opinion

- **Clarity and Maintainability:**
  Since the intended audience is technical but with varying skills, clarity is paramount. Documenting the trade-offs (_impurity vs. explicit declaration, shared vs. host-specific modules_) will help readers understand your rationale.

- **Modularity:**
  Emphasizing modularity—using host-specific modules only when necessary—is a best practice. It keeps your overall configuration lean and easier to navigate.

- **Avoiding Unnecessary Dependencies:**
  Your insistence on avoiding extra dependencies (`awk`, `grep`, etc.) is solid. In a NixOS context, simplicity in module evaluation is key to reproducible builds and manageable flakes.

**Opinion:**
In my view, your approach of housing the microcode configuration in the host directory is a pragmatic compromise. It sidesteps the pitfalls of making the flake impure and retains the benefits of flakes (_modularity, clarity, reproducibility_) without over-engineering the solution. Remember, sometimes a bit of redundancy for the sake of clarity and maintainability is a fair trade-off.

=== Code examples!

(1) Impure flake

[source,nix]
----
{
  lib,
  ...
}: let
  cpuVendor = let f = builtins.readFile "/proc/cpuinfo";
              in builtins.substring
                   (builtins.stringLength "vendor_id\t: ")
                   (builtins.stringLength (builtins.head (builtins.filter
                      (line: builtins.match "vendor_id\\s*:" line != null)
                      (builtins.lines f))))
                   (builtins.head (builtins.filter
                      (line: builtins.match "vendor_id\\s*:" line != null)
                      (builtins.lines f)));
in {
  hardware.cpu.amd.updateMicrocode   = cpuVendor == "AuthenticAMD";
  hardware.cpu.intel.updateMicrocode = cpuVendor == "GenuineIntel";
}
----

(2) This is the way the module is actually implemented

(3) Relying on external tools to automate decision magic

[source,nix]
----
{
  lib,
  pkgs,
  ...
}: let
  cpuVendor = builtins.readFile (pkgs.runCommand "cpu-vendor" {} ''
    grep -m1 "vendor_id" /proc/cpuinfo | awk '{print $3}' > $out
  '');
in {
  hardware.cpu.amd.updateMicrocode = cpuVendor == "AuthenticAMD";
  hardware.cpu.intel.updateMicrocode = cpuVendor == "GenuineIntel";
}
----